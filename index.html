<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.9/d3.js"></script>
    <title>Map Data</title>
    <style>
        body {
            background-color: black;
            color: white;
            cursor: crosshair;
            text-align: center;
            font-size: 50px;
            margin: 0;
            /* overflow: hidden; /* Hide scrollbars */
        }
    </style>
</head>
<body>
    <!-- Initialize a select button -->
    <h2>Scroll down to see the data.</h2>
    <p>YEAR<br /><select id="selectButton"></select></p>
    <div class="container">
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <!-- Bubble Cloud Graphs -->
        <div id='vis' class="svg-container"></div>
        <script>
            /*
            * Helper function to convert a number into a string
            * and add commas to it to improve presentation.
            */
            function addCommas(nStr) {
                nStr += '';
                var x = nStr.split('.');
                var x1 = x[0];
                var x2 = x.length > 1 ? '.' + x[1] : '';
                var rgx = /(\d+)(\d{3})/;
                while (rgx.test(x1)) {
                    x1 = x1.replace(rgx, '$1' + ',' + '$2');
                }

                return x1 + x2;
            }

            // bubbleChart creation function; instantiate new bubble chart given a DOM element to display it in and a dataset to visualise
            function bubbleChart() {
                const width = (window.innerWidth > 0) ? window.innerWidth : screen.width;
                const height = width;

                // location to centre the bubbles
                const centre = { x: width / 2, y: height / 2 };

                // strength to apply to the position forces
                const forceStrength = 0.03;

                // these will be set in createNodes and chart functions
                let svg = null;
                let bubbles = null;
                let labels = null;
                let nodes = [];
                let allYears = null;
                let totalGov = 0;
                let totalKan = 0;
                let total = 0;

                // charge is dependent on size of the bubble, so bigger towards the middle
                function charge(d) {
                    return Math.pow(d.radius, 2.0) * 0.01
                }

                // create a force simulation and add forces to it
                let simulation = d3.forceSimulation()
                    .force('charge', d3.forceManyBody().strength(charge))
                    .force('center', d3.forceCenter(centre.x, centre.y))
                    .force('x', d3.forceX().strength(forceStrength).x(centre.x))
                    .force('y', d3.forceY().strength(forceStrength).y(centre.y))
                    .force('collision', d3.forceCollide().radius(d => d.radius + 1));

                // force simulation starts up automatically, which we don't want as there aren't any nodes yet
                simulation.stop();

                // set up colour scale
                const fillColour = d3.scaleOrdinal(d3.schemeCategory10);

                // data manipulation function takes raw data from csv and converts it into an array of node objects
                // each node will store data and visualisation values to draw a bubble
                // rawData is expected to be an array of data objects, read in d3.csv
                // function returns the new node array, with a node for each element in the rawData input
                function createNodes(rawData) {
                    // use max size in the data as the max in the scale's domain
                    // note we have to ensure that size is a number
                    const maxSize = d3.max(rawData, d => +d.size);

                    // size bubbles based on area
                    const radiusScale = d3.scaleSqrt()
                        .domain([0, maxSize])
                        .range([0, 80])

                    // use map() to convert raw data into node data
                    const myNodes = rawData.map(d => ({
                        ...d,
                        radius: radiusScale(+d.size),
                        size: +d.size,
                        buyer: d.buyer,
                        x: Math.random(),
                        y: Math.random()
                    }))

                    return myNodes;
                }

                // main entry point to bubble chart, returned by parent closure
                // prepares rawData for visualisation and adds an svg element to the provided selector and starts the visualisation process
                let chart = function chart(selector, rawData) {

                    total = d3.sum(rawData, d => +d.size);

                    //=======================================================GET ONE GRAPH PER YEAR=======================================================
                    // group by year
                    allYears = d3.group(rawData, d => d.year)
                    //var options = ['Years', 'Show All']

                    // add the options to the button
                    d3.select("#selectButton")
                        .selectAll('myOptions')
                        .data(allYears.keys())
                        .enter()
                        .append('option')
                        .text(function (d) { return d; }) // text showed in the menu
                        .attr("value", function (d) { return d; }) // corresponding value returned by the button

                    // When the button is changed, update data
                    d3.select("#selectButton").on("change", function (event, d) {
                        // recover the option that has been chosen
                        const selectedOption = d3.select(this).property("value")
                        // run an update function with this selected option
                        updateData(Array.from(allYears.get(selectedOption).values()))
                    })

                    function updateData(newData) {
                        d3.selectAll('svg').remove();

                        // create a force simulation and add forces to it
                        simulation = d3.forceSimulation()
                            .force('charge', d3.forceManyBody().strength(charge))
                            .force('center', d3.forceCenter(centre.x, centre.y))
                            .force('x', d3.forceX().strength(forceStrength).x(centre.x))
                            .force('y', d3.forceY().strength(forceStrength).y(centre.y))
                            .force('collision', d3.forceCollide().radius(d => d.radius + 5));

                        nodes = createNodes(newData);

                        // create svg element inside provided selector
                        svg = d3.select(selector)
                            .append('svg')
                            .attr('width', width)
                            .attr('height', height)

                        // MUST CALCULATE TOTALS UNTIL NEW DATA DATE
                        totalGov = 0;
                        totalKan = 0;
                        if (newData[0].buyer === 'gov')
                        {
                            totalKan = parseInt(total) - d3.sum(newData, d => +d.size);
                            totalGov = d3.sum(newData, d => +d.size);
                        }
                        else
                        {
                            totalGov = parseInt(total) - d3.sum(newData, d => +d.size);
                            totalKan = d3.sum(newData, d => +d.size);
                        }
                        //total = parseInt(total) - parseInt(totalGov);

                        // buyer title
                        svg.append("text")
                            .attr("x", (width / 6))
                            .attr("y", 40)
                            .attr("text-anchor", "middle")
                            .style("font-size", "25px")
                            .style('fill', 'white')
                            .style("text-decoration", "underline")
                            .text("Government: " + addCommas(totalGov) + " SqM");

                        // buyer title
                        svg.append("text")
                            .attr("x", (width / 2))
                            .attr("y", 40)
                            .attr("text-anchor", "middle")
                            .style("font-size", "25px")
                            .style('fill', 'white')
                            .style("text-decoration", "underline")
                            .text("Total Area: " + addCommas(total) + " SqM");

                        // buyer title
                        svg.append("text")
                            .attr("x", (width - (width / 6)))
                            .attr("y", 40)
                            .attr("text-anchor", "middle")
                            .style("font-size", "25px")
                            .style('fill', 'white')
                            .style("text-decoration", "underline")
                            .text("Kanehsatake: " + addCommas(totalKan) + " SqM");

                        // bind nodes data to circle elements
                        elements = svg.selectAll('.bubble')
                            .data(nodes, d => d.year)
                            .enter()
                            .append('g')

                        bubbles = elements
                            .append('circle')
                            .classed('bubble', true)
                            .attr('r', d => d.radius)
                            .attr('fill', d => fillColour(d.size))

                        // labels
                        labels = elements
                            .append('text')
                            .attr('dy', '.3em')
                            .style('text-anchor', 'middle')
                            .style('font-size', 20)
                            .style('fill', 'white')
                            .style('stroke', 'white')
                            .text(d => d.size + ' SqM')

                        // set simulation's nodes to our newly created nodes array
                        // simulation starts running automatically once nodes are set
                        simulation.nodes(nodes)
                            .on('tick', ticked)
                            .restart();
                    }
                    //=======================================================GET ONE GRAPH PER YEAR=======================================================

                    // convert raw data into nodes data
                    nodes = createNodes(rawData);

                    // create svg element inside provided selector
                    svg = d3.select(selector)
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height)

                    // bind nodes data to circle elements
                    elements = svg.selectAll('.bubble')
                        .data(nodes, d => d.year)
                        .enter()
                        .append('g')

                    bubbles = elements
                        .append('circle')
                        .classed('bubble', true)
                        .attr('r', d => d.radius)
                        .attr('fill', d => fillColour(d.buyer))

                    // labels
                    labels = elements
                        .append('text')
                        .attr('dy', '.3em')
                        .style('text-anchor', 'middle')
                        .style('fill', 'white')
                        .style('font-size', 10)
                        .text(d => d.year)

                    // set simulation's nodes to our newly created nodes array
                    // simulation starts running automatically once nodes are set
                    simulation.nodes(nodes)
                        .on('tick', ticked)
                        .restart();
                }

                // callback function called after every tick of the force simulation
                // here we do the actual repositioning of the circles based on current x and y value of their bound node data
                // x and y values are modified by the force simulation
                function ticked() {
                    bubbles
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y)

                    labels
                        .attr('x', d => d.x)
                        .attr('y', d => d.y)
                }

                // return chart function from closure
                return chart;
            }

            // new bubble chart instance
            let myBubbleChart = bubbleChart();

            // function called once promise is resolved and data is loaded from csv
            // calls bubble chart function to display inside #vis div
            function display(data) {
                myBubbleChart('#vis', data);
            }

            // load data
            d3.csv('data/data.csv').then(display);
        </script>
    </div>
</body>
</html>